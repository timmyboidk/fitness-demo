import * as SecureStore from 'expo-secure-store';

jest.mock('expo-secure-store');

// Mock helpers
const mockRequestUse = jest.fn();
const mockResponseUse = jest.fn();

const mockInstance = {
    interceptors: {
        request: { use: mockRequestUse },
        response: { use: mockResponseUse }
    },
    defaults: { headers: { common: {} } },
    get: jest.fn(),
    post: jest.fn(),
};

jest.mock('axios', () => {
    // Create a mock function to represent the default export 'axios'
    const mockAxios: any = jest.fn();

    // Attach properties
    mockAxios.create = jest.fn(() => mockInstance);
    mockAxios.isAxiosError = jest.fn();
    mockAxios.defaults = { headers: { common: {} } };

    return {
        __esModule: true,
        default: mockAxios,
        // Also expose these matching the default object
        create: mockAxios.create,
        isAxiosError: mockAxios.isAxiosError,
    };
});

import client from '../api/client';

describe('API Client', () => {

    it('should be defined', () => {
        expect(client).toBeDefined();
    });

    describe('Environment', () => {
        it('should have interceptors registered', () => {
            expect(mockRequestUse).toHaveBeenCalled();
            expect(mockResponseUse).toHaveBeenCalled();
        });
    });

    describe('Auth Interceptor', () => {
        it('should inject token if exists', async () => {
            (SecureStore.getItemAsync as jest.Mock).mockResolvedValue('my-token');

            const calls = mockRequestUse.mock.calls;
            // The Auth interceptor is the 2nd one registered
            const authInterceptor = calls[calls.length - 1][0];

            const config = { headers: { common: {} } };
            await authInterceptor(config);

            expect(config.headers['Authorization']).toBe('Bearer my-token');
        });

        it('should not inject token if missing', async () => {
            (SecureStore.getItemAsync as jest.Mock).mockResolvedValue(null);

            const calls = mockRequestUse.mock.calls;
            const authInterceptor = calls[calls.length - 1][0];

            const config = { headers: { common: {} } };
            await authInterceptor(config);

            expect(config.headers['Authorization']).toBeUndefined();
        });
    });

    describe('Response Interceptor', () => {
        it('should handle 401 and delete token', async () => {
            const calls = mockResponseUse.mock.calls;
            const errorHandler = calls[0][1];

            const error = { response: { status: 401 } };

            try {
                await errorHandler(error);
            } catch (e) {
                expect(e).toBe(error);
            }

            expect(SecureStore.deleteItemAsync).toHaveBeenCalledWith('user_token');
        });
    });
});
